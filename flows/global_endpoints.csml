import {FormarAiSpeaking, FormatPronunciation, CalculateOutcome,AddFieldsToActivities} from global_functions
import {GroupBy,ObjectToArray,GetParameter} from global_utility

start:
  say "You are in global_endpoints"

  hold

  goto flow menu
  
fn GetActivity():

  use "https://staging-my.chatclass.com.br/supersecretcsmlapi/activity/5acfb01c95aeb700114d9a4e-aisp"
  as ai_activity

  use "https://staging-my.chatclass.com.br/supersecretcsmlapi/activity/5aeb5046f25b1200110ff369"
  as pronunciation

  do req = HTTP("{{pronunciation}}")
  do res = req.send()

  do type = res.header.type

  if (type == "AI_SPEAKING") {
    return { 
      "type": type,
      "route": {"step_name":"question_start","flow_name":"activity_aispeaking"},
      "current_activity": FormarAiSpeaking(res)}
  }
  else if (type == "PRONUNCIATION") {
    return { 
      "type": type,
      "route": {"step_name":"question_start","flow_name":"activity_pronunciation"},
      "current_activity": FormatPronunciation(res)}
  } 
  else {
    return false
  }

fn SpeakingProcess(user_audio_event):
  do req = HTTP("https://chattest.proxy.beeceptor.com/asr")
  do res = req.send()

  return {
      "score": res.score,
      "understoodWords": res.understood_words,
      "missingWords": res.missing_words,
  } 

fn GetAirtableActivities(table, key):
  do req = HTTP("https://api.airtable.com/v0/apphZsSVCfPb6PJ6w/{{table}}").set({"Authorization":"Bearer {{key}}"})
  do body = req.get().send()

  do records = body.records

  do questions = []

  foreach (record, index) in records {
    do question = {
      "id": record.fields["ID"],
      "activity_id": record.fields.activity_id,
      "done": false,
      "type": record.fields.activity_type,   
      "prompt": record.fields.prompt,
      "answer": "",
      "outcome": "",
      "module_name": record.fields.module_name,
      "module_id": record.fields.module_id,
      "unit_name": record.fields.unit_name,
      "unit_id": record.fields.unit_id,
      "activity_name": record.fields.activity_title,
      "attemps": 0,
      "max_attemps": 1,
    }

    if(record.fields.media_id){
      do question["media"] = record.fields.media_id
    }
    
    do question = AddQuestionSpecificExtraFields(question, record)

    do questions.push(question)
  }

  debug "quest√µes adicionadas"

  do activities = ObjectToArray(GroupBy("activity_id", questions), [{"done": false}], "questions")

  debug "atividades criadas"

  do activities = AddFieldsToActivities(activities, ["module_name", "unit_name", "module_id", "unit_id", "goto", "activity_name"])

  return activities



fn AddQuestionSpecificExtraFields(question, record):
  if (question["type"] == "DIALOG" || question["type"] == "VOCABULARY"){
    do question["goto"] = { "step": "start", "flow": "activity_quiz" }

    if(record.fields.options){
      do options = record.fields.options.match_regex("\s*\<option\>(.|\n)+?\<\/option\>")
      do options.push(record.fields.options.match_regex("\s*\<answer\>(.|\n)+?\<\/answer\>")[0])

      do question["options"] = options
    }
  }
  else if (question["type"] == "INSTRUCTIONAL"){
    do question["goto"] = { "step": "message", "flow": "activity_instructional" }
  }
  else if (question["type"] == "PROMPT"){
    do question["goto"] = { "step": "message", "flow": "activity_instructional" }
  }
  else if (question["type"] == "SURVEY"){
    do question["goto"] = { "step": "message", "flow": "activity_survey" }
  }
  else if (question["type"] == "FINAL"){
    do question["goto"] = { "step": "message", "flow": "activity_instructional" }
  }

  return question

fn PostStats(key, activity, metadata):
  do outcome = CalculateOutcome(activity.questions)
  do answers = GetParameter(activity.questions, "answer", {"key": "options", "value": NULL}).join(";")

  do req = HTTP("https://api.airtable.com/v0/apphZsSVCfPb6PJ6w/stats").set({"Authorization":"Bearer {{key}}"})
  
  do payload = {
    "records": [
        {
            "fields": {
                "activity_id": activity.id.to_string(),
                "outcome": outcome.to_string(),
                "answer": answers,
            }
        }
    ]
  }

  if(metadata.user_id){
    do payload.records[0].fields["user_id"] = metadata.user_id
  }

  if(metadata.platform_user_name){
    do payload.records[0].fields["platform_user_name"] = metadata.platform_user_name
  }
  
  do res = req.post(payload).send()

  if(res.error){
    debug res.error
    debug stats
  }


fn PostMisunderstood(key, activity, event, metadata):

  do req = HTTP("https://api.airtable.com/v0/apphZsSVCfPb6PJ6w/misunderstood").set({"Authorization":"Bearer {{key}}"})
  
  do payload = {
    "records": [
        {
            "fields": {
                "activity_id": activity.id.to_string(),
                "type": event.get_type(),
            }
        }
    ]
  }

  if(event.get_type() == "text"){
    do payload.records[0].fields["payload"] = event.text.to_string()
  }

  if(metadata.user_id){
    do payload.records[0].fields["user_id"] = metadata.user_id
  }

  if(metadata.platform_user_name){
    do payload.records[0].fields["platform_user_name"] = metadata.platform_user_name
  }
  
  do res = req.post(payload).send()

  if(res.error){
    debug res.error
    debug stats
  }


fn PostMessage(key, event_data, payload):
  do type = event_data.type
  do text = event_data.text

  do req = HTTP("https://api.airtable.com/v0/apphZsSVCfPb6PJ6w/message_log").set({"Authorization":"Bearer {{key}}"})
  
  do payload = {
    "records": [
        {
            "fields": {
                "type": type,
                "source": payload.source.to_string(),
                "course_id": payload.course_id.to_string(),
                "bot_id": payload.bot_id.to_string(),
                "payload": text,
            }
        }
    ]
  }

  if(payload.metadata.user_id){
    do payload.records[0].fields["user_id"] = payload.metadata.user_id.to_string()
  }

  if(payload.metadata.platform_user_name){
    do payload.records[0].fields["platform_user_name"] = payload.metadata.platform_user_name.to_string()
  }

  do res = req.post(payload).send()

  if(res.error){
    debug res.error
    debug stats
  }

fn GetCEP(coordinates):
  do latitude = coordinates.latitude.to_string()
  do longitude = coordinates.longitude.to_string()
  
  do url = "https://nominatim.openstreetmap.org/reverse?format=json&lat={{latitude}}&lon={{longitude}}&zoom=18&addressdetails=1"

  do address = HTTP(url).get().send()

  if(address["error"]){
    return false
  }

  do most_reliable = {}

  if (address["address"]) {

      do most_reliable["city"] = address.address.city
      do most_reliable["postal_code"] = address.address.postcode
      do most_reliable["label"] = address.display_name      

    }
  

  return most_reliable

fn CreateUserDataLayer(payload):
  do url = "https://cloud-hub-data-staging.azurewebsites.net/user"
  do res = HTTP(url).post(payload).send()
  return res._id

fn PostDataHub(payload, id):
  do url = "https://cloud-hub-data-staging.azurewebsites.net/user/{{id}}"
  do res = HTTP(url).put(payload).send()

  return res

fn SubscribeReminder(data):

  do payload = {
    "user_session_id": data.user_session,
    "subscription": {
      "type": "REMINDER",
      "delay": data.delay
    }
  }

  do url = "url"
  do res = HTTP(url).put(payload).send()

  return "id"
 
fn SubscribeBroadcast(data):

  do payload = {
    "user_session_id": data.user_session,
    "subscription": {
      "type": "BROADCAST",
    }
  }

  do url = "url"
  do res = HTTP(url).put(payload).send()

  return "id"
import {RemoveString,FindObjectArray,FilterObjectArray,RemoveDuplicates} from global_utility
import {PostMessage, PostStats} from global_endpoints
import {ErrorReducer} from reducers

start:
  say "Welcome to functions lib ðŸ‘‹"

  hold

  goto flow menu

//------------------------------------------------------------------------------------------
// Builders
//------------------------------------------------------------------------------------------

fn MessageBuilder(action, state):

  if(action == "FROM_OPTIONS"){
    do message = []
    foreach (el) in  state {
      do message.push("{{el.index}} - {{el.name}}")
    }

    return message
  }
  else if (action == "RENDER_MENU"){
    do must_have_fields = ["options"]
    do error =  Validate(state, must_have_fields)
    if (error) {
        return error
    }

    do menu = []
    foreach (option, index) in state.options {
      do menu.push("{{index}} - {{option}}")
    }

    return menu.join("\n")
  }
  else {
   return ErrorReducer("MessageBuilder", "ACTION_NOT_FOUND")
  }

fn OptionBuilder(action, state):
  

fn ActivityBuilder(activity, build):

fn QuestionBuilder(question, build):

fn ConfigurationBuilder(configuration, build):

fn CourseBuilder(course, build):

//------------------------------------------------------------------------------------------//------------------------------------------------------------------------------------------
// Validators
//------------------------------------------------------------------------------------------

fn ValidateType(message, type):
  if(type == "TEXT"){
    if(event.text){
      return {"valid": true}
    }
    else {
      return {"valid": false}
    }
  }
  if(type == "PAYLOAD"){
    if(event.payload){
      return {"valid": true}
    }
    else {
      return {"valid": false}
    }
  }
  if(type == "LOCALIZATION"){
    if(event.get_type() == "payload"){
      return {"valid": true}
    }
    else {
      return {"valid": false}
    }
  }
  else {
    return ErrorReducer({"field": "type"}, "MISSING_FIELD")
  }

fn ValidateName(user_message):
  do message_splited = user_message.split(" ")
  debug message_splited
  do remove_words = ["meu", "nome", "[Ã©|e]", "oi", "me", "ol[a|Ã¡]", "sou", "^[0-9A-Za-z]"]
  do name = []
  foreach (text) in message_splited {
    do to_remove = false
    if(text.match_regex("(?i)\\b([a-z]+)\\b")){
      foreach (word_to_remove) in remove_words {
        if(text.match_regex("(?i)\\b({{word_to_remove}})\\b")){
          do to_remove = true
        }
      }
      if(to_remove){
        continue
      }
      else {
        do name.push(text)
      }
    }
  }

  if(name == []){
    return {"valid": false}
  }
  else {
    do last_item_index = name.length() - 1
    do camelcase_names = []

    foreach (word) in name{
      do camelcase_names.push(CamelCase(word))
    } 

    do name_validation = {
      "valid": true,
      "first_name": camelcase_names[0], 
      "last_name": camelcase_names[last_item_index],
      "full_name": camelcase_names.join(" ")
    }

    return name_validation
  }


fn Validate(data, fields):

  return NULL

fn ValidateEmail(email):
  if(email.match_regex("([a-z0-9_+]([a-z0-9_+.]*[a-z0-9_+])?)@([a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,6})")){
    return { "valid": true }
  }
  else {
    return { "valid": false }
  }

fn ValidateCPF(cpf):
  if(cpf.match_regex("^[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}$")){
    return { "valid": true}
  }
  else {
    return { "valid": false }
  }

/*
* Return the valid alternative command
*/
fn ValidateResponse(event, alternatives):

  do user_message = event.text

  do validation = {
    "valid": false,
    "alternative": NULL,
  }

  if(event.get_type() != "text"){
    return {"valid": false, "alternative": NULL}
  }

  do global_command = GlobalCommands(event.text)

  if(global_command){
    return {"valid": true, "alternative": global_command, "global": true}
  }

  foreach (alternative) in alternatives {
    if (user_message.match_regex("(?i)\s*({{alternative.command}})\s*")){
      do validation = {"valid": true, "alternative": alternative}
    }
  }

  return validation


//------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------

fn GlobalCommands(event):
// add parameters for admin commands
  if(event.match("#restart")){
    return { "step": "restart", "flow": "global_controller" }
  } 
  else if (event.match_regex("#stop")){
    return { "step": "b2b", "flow": "global_controller" }     
  } 
  else if (event.match_regex("(?i)(#help)")){
    return { "step": "start", "flow": "help" }   
  } 
  else if (event.match_regex("(?i)(#home)")){
    return { "step": "b2b", "flow": "global_controller" }   
  } 
  else if (event.match_regex("(?i)(#profile)")){
    return { "step": "start", "flow": "profile" }  
  } 
  else if (event.match_regex("(?i)(#modules)")){
    return { "step": "start", "flow": "content_navigation" }  
  } 
  else if (event.match_regex("(?i)(#settings)")){
    return { "step": "start", "flow": "settings" } 
  }
  else if (event.match_regex("(?i)(#goempiricus)")){
    return { "step": "empiricus", "flow": "global_controller" } 
  }
  else if (event.match_regex("(?i)(#gobahia)")){
    return { "step": "bahia", "flow": "global_controller" } 
  }
  else if (event.match_regex("(?i)(hsm:cr_menu2)")){
    return {"step": "start", 
            "flow": "hsm" , 
            "hsm": { "name": "cr_menu2", "options": ["#goempiricus", "#gobahia", "#restart"] } 
            } 
  }    
  else {
    return false
  }

        
//------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------
        
        
//TODO: Merge option selected to option select
fn OptionSelected(user_message, options):

  do wide_command = GlobalCommands(user_message)

  if (wide_command){
    return wide_command
  } else {
    foreach (option) in options {
      if (user_message.match_regex("(?i)({{option.name}})")){
        return { "step": option.step_name, "flow": option.flow_name }  
      }
    }
    return false
  }

fn FormarAiSpeaking(api_response):
  do questions = []

    foreach (question, index) in api_response.content.items {

      if(question.suggested_expressions){
        do tmp = {
          "id": index, 
          "messages": [], 
          "requiredExpressions": question.required_expressions,
          "suggestedExpressions": question.suggested_expressions,
          "examples": [],
          "attempts": 1,
          "attemptsLimit": 3,
      }
      } else {
        do tmp = {
          "id": index, 
          "messages": [], 
          "requiredExpressions": question.required_expressions,
          "examples": [],
          "attempts": 1,
          "attemptsLimit": 3,
      }
      }

      foreach (message) in question.messages {
        do tmp.messages.push(message.text)
      }

      if(question.sample_answer)
        foreach (example) in question.sample_answer {
          do tmp.examples.push(example.media.metadata.tts_original_text)
        }
      

      do questions.push(tmp)
    }

  return { "id": res.header.id, "questions": questions }

fn FormatPronunciation(api_response):
  do questions = []

    foreach (question, index) in api_response.content.items {

      if(question.suggested_expressions){
        do tmp = {
          "id": index, 
          "messages": [], 
          "requiredExpressions": question.required_expressions,
          "suggestedExpressions": question.suggested_expressions,
          "examples": [],
          "attempts": 1,
          "attemptsLimit": 3,
      }
      } else {
        do tmp = {
          "id": index, 
          "messages": [], 
          "requiredExpressions": question.required_expressions,
          "examples": [],
          "attempts": 1,
          "attemptsLimit": 3,
      }
      }

      foreach (message) in question.messages {
        do tmp.messages.push(message.text)
      }

      if(question.sample_answer)
        foreach (example) in question.sample_answer {
          do tmp.examples.push(example.media.metadata.tts_original_text)
        }
      

      do questions.push(tmp)
    }

  return { "id": res.header.id, "questions": questions }


/**
 * Get step that done == false && < order key value in that group
 * activities: acitivity[]
 * 
 * return: activity
 */
fn GetNextActivity(activities):
  if(activities == NULL){
    return []
  }
  do activitiesNotDone = FilterObjectArray(activities, "done", "==", false)
  return FindObjectArray(activitiesNotDone, "min", "item")

/*
*
*/
fn GetNextQuestion(questions):
  if(questions == NULL){
    return []
  }
  do activitiesNotDone = FilterObjectArray(questions, "done", "==", false)
  return FindObjectArray(activitiesNotDone, "min", "id")


/**
 * Set activity as done in course data
 * current_activity: activity
 * course_data: activity[]
 */
fn SetActivityDone(current_activity, course_data):
  if(current_activity == NULL || course_data == NULL){
    return NULL
  }
  foreach (acitivity, index) in course_data {
    if(acitivity.id == current_activity.id) {
      do course_data[index].done = true
    }    
  }
  return course_data

fn SetQuestionDone(current_question, activityValues):
  foreach (question, index) in activityValues {
    if(question.id == current_question.id) {
      do activityValues[index].done = true
      do activityValues[index].answer = current_question.answer
      do activityValues[index].outcome = current_question.outcome
    }    
  }
  return activityValues


//------------------------------------------------------------------------------------------
// Selectors
//------------------------------------------------------------------------------------------

/*
*
*/
fn QuizSelection(event, correctOption, payload):
  do must_have_fields = ["metadata", "course_id", "airtable_key"]
  do error = Validate(payload, must_have_fields)
  if(error){
      return error
  }
  
  do PostMessage(
      payload.airtable_key, 
      {
        "type": event.get_type(),
        "text": event.text
      }, 
      {
        "source": "USER",
        "bot_id": "B2B-Demo",
        "metadata": payload.metadata,
        "course_id": payload.course_id,
      }
    )

  if(event.get_type() != "text"){
    return {"isCorrect": NULL, "changeFlow": false, "goto": NULL, "dontMatch": true}
  }

  do userMessage = event.text

  //TODO: Change wide command to global_command
  do global_command = GlobalCommands(userMessage)

  debug global_command

  if (global_command){
    return {"isCorrect": NULL, "changeFlow": true, "goto": global_command, "dontMatch": false}
  }
  //TODO: ACCEPT N OPTIONS IN REGEX
  else if (
    userMessage.match_regex("(?i)(\\ba\\b)")
    || userMessage.match_regex("(?i)(\\bb\\b)")
    || userMessage.match_regex("(?i)(\\bc\\b)")
    || userMessage.match_regex("(?i)(\\bd\\b)")
  ){

    do isCorrect = userMessage.match_regex("(?i)\s*({{correctOption}})\s*")

    return {"isCorrect": isCorrect, "changeFlow": false, "goto": NULL, "dontMatch": false}
  }
  else {
    return {"isCorrect": NULL, "changeFlow": false, "goto": NULL, "dontMatch": true}
  }

/*
*
*/
fn SelectCourse(userMessage, options):

  do wide_command = GlobalCommands(userMessage)

  if (wide_command){
    return { "valid": true, "goto": wide_command , "payload": NULL}
  } else {
    foreach (option) in options {
      //TODO: Change regex for boundary selection
      if (userMessage.match_regex("(?i)({{option.name}})")){
        return { "valid": true, "goto": NULL, "course": option }  
      } 
    }
    return { "valid": false, "goto": NULL, "payload": NULL }  
  }

/*
*
*/
fn MenuSelection(userMessage, options):

  do wide_command = GlobalCommands(userMessage)

  if (wide_command){
    return wide_command
  } else {
    foreach (option) in options {
      //TODO: Change regex for boundary selection
      if (userMessage.match_regex("(?i)({{option.name}})")){
        return { "step": option.step_name, "flow": option.flow_name }  
      } 
    }
    return false
  }

//------------------------------------------------------------------------------------------
// 
//------------------------------------------------------------------------------------------

/*
*
*/
fn RenderOptions(activity):

  //TODO: Add N options rendering
  do optionsLetters = ["A", "B", "C", "D", "E", "F", "G"]
  do options = []
  do correctOption = ""

  foreach (option, index) in Shuffle(activity["options"]) {
    do temp = option.match_regex("\<answer\>(.|\n)*?\<\/answer>")
    if(temp){
      do correctOption = optionsLetters[index]
    }
    do option = RemoveString(option,["\n","<answer>",
      "</answer>","<option>","</option>"])
    do options.push([optionsLetters[index], option].join(" - "))
  }

  do optionsToRender = options.join("\n")

  return {"options": optionsToRender, "answer": correctOption}

/*
*
*/
fn RenderHSM(hsm):

  if(hsm.name == "cr_menu2"){
    return SendHSM(
      {
        "namespace": "c2b73b20_1ea1_4044_bea8_49cb50712de1",
        "name": "cr_menu2",
        "code": "en_US",
        "title": NULL,
        "body": NULL,
        "buttons": hsm.options
      }
    )
  }
  else {
    return NULL
  }


/**
* Send a HSM for user
* @namespace: string - Ex.: "c2b73b20_1ea1_4044_bea8_49cb50712de1"
* @name: string - Name of hsm, ex: "cr_menu2"
* @code: string - Code of hsm, ex: "en_US"
* @title: string
* @body: string
* @buttons: string[] - Options payload for hsm
*/
fn SendHSM(hsm):
  do components = []

  if (hsm.title) {
    do components.push(
      {
      "type": "header",
      "parameters": [
        {
            "type": "text",
            "text": hsm.title
        }
      ]
      }
    )
  }

  if (hsm.body) {
    do components.push(
      {
      "type": "body",
      "parameters": [
        {
            "type": "text",
            "text": hsm.body
        }
      ]
      }
    )
  }

  foreach (button, index) in hsm.buttons {
    do components.push({
        "type": "button",
        "sub_type": "quick_reply",
        "index": index,
        "parameters": [
            {
            "type": "payload",
            "payload": button
          }
        ]
      },
    )
  }

  return {
    "namespace": hsm.namespace,
    "name": hsm.name,
    "code": hsm.code,
    "components": components
  }

/*
*
*/
fn CalculateOutcome(questions):
  do correct_activities = FilterObjectArray(questions, "outcome", "==", "POSITIVE")
  //TODO: JOin return 0 conditions in one if
  if(correct_activities.length() == 0){
    return 0
  }
  if (questions.length() == 0){
    return 0
  }
  return correct_activities.length() / questions.length()

/*
*
*/
fn RenderNextQuestion(current_question, current_activity, course_data, current_flow, metadata, airtable_key):
  if(current_question == []){
    do PostStats(airtable_key, current_activity, metadata)
    do course_data = SetActivityDone(current_activity, course_data)
    
    return {"course_data": course_data, 
            "goto": { "step": "next_activity" , "flow": "global_controller"}
            }
  }
  else {
    return { "goto": { "step": "question" , "flow": current_flow}}
  }

/*
* Add fields to activities based o questions keys
* @array_activities
* @array_keys
*/
fn AddFieldsToActivities(array_activities, array_keys):
  do temp = []
  foreach (activity) in array_activities{
    foreach (key) in array_keys{
      do activity[key] = activity.questions[0][key]
    }
    do temp.push(activity)
  }
  
  return temp

/*
* Get all courses modules names
*/
fn GetCoursesModules(course_data):
  do temp = []

  foreach (activity) in course_data {
    do temp.push({
      "name": "{{activity.module_name}}",
      "goto": activity.goto,
      "unit_name": activity.unit_name,
      "activity.module_name": activity.module_name
    })
  }

//TODO: Change  field name to remove
  return RemoveDuplicates(temp, "name")

/*
* Get activities names by unit_name
*/
fn GetActivitiesByUnit(course_data, unit_name):
  do temp = []

  foreach (activity) in course_data {
    if(activity.unit_name == unit_name){
      do temp.push({
        "name": "{{activity.unit_name}}: {{activity.activity_name}}",
        "goto": activity.goto
      })
    }
  }

  return RemoveDuplicates(temp, "name")


//------------------------------------------------------------------------------------------
// Factory
//------------------------------------------------------------------------------------------


fn FindActivityByField(activities, field, value):
  do temp = {}
  foreach (activity) in activities{
    if(activity[field].to_string() == value.to_string()){
      do temp = activity
    }
  }
  return temp 

fn FilterOptions(options, field, value):
  do temp = []
  foreach (option) in options{
    if(option[field].to_string() == value.to_string()){
      do temp.push(option)
    }
  }

  return temp

fn FixIndex(options):
  foreach (option, index) in options{
    do options[index].index = index
  }

  return options


/**
* Select a option beetween an array of options
* @param {event} event
* @param {options<array>} data
* @param {string} field
* @return {option}
*/
fn SelectOption(event, data, field):

  do user_message = event.text

  do global_command = GlobalCommands(user_message)

  if (global_command) {
    return { "change_flow": true, "goto": global_command }
  } 
  else {
    foreach (item) in data {
      do option = item.index.to_string()
      if (option.match_regex("(?i)({{user_message}})")) {
        return item
      }
    }
    return { "dont_match": true }
  }


fn CamelCase(text):
  do slice = text.slice(1)
  do split = text.split(slice)
  do camel_case = [split[0].to_uppercase(), slice].join("")
  return camel_case